local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Iris = require(ReplicatedStorage.Packages.Iris)
local ImGizmo = require(ReplicatedStorage.Packages.ImGizmo)

local Core = require(ReplicatedStorage.Game.Modules.Core)

local DeveloperGuiController = Knit.CreateController { Name = "DeveloperGuiController" }

local PickaxeService
local DialogueService

local DebugFolder = ReplicatedStorage.Player.Debug

local DialoguePromptTag
local MiningRange = 0
local Stats = {
    FPS = 0;
    Ping = 0;
    Fullscreen = false;
    TabbedIn = true;
}

-- [[ PRIVATE ]] --

local function HelpMarker(helpText: string)
    Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
    local text = Iris.Text({ "(?)" })
    Iris.PopConfig()

    Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
    if text.hovered() then
        Iris.Tooltip({ helpText })
    end
    Iris.PopConfig()
end

local function GetPathOfDebugValue(Value :Instance, RootFolder :Folder) :string
    local Current = Value
    local Path = {}

    while Current and Current ~= RootFolder do
        table.insert(Path, 1, Current.Name)
        Current = Current.Parent
    end

    if Current == RootFolder then
        return RootFolder.Name.."/"..table.concat(Path, "/")
    end

    return "INVALID: OBJECT NOT DESCENDANT"
end



-- [[ PUBLIC ]] --

function DeveloperGuiController:AutoGeneratedWindow()
    local Window = Iris.Window({"Auto-Generated", false, false, false, true})
    if Window.state.isOpened and Window.state.isUncollapsed then
        Iris.Text({"Everything in this window is auto generated, although information is accurate it may be hard to find or not displayed as intended!"})
        Iris.Tree({"All values"})
        for _, DebugValue :ValueBase in pairs(ReplicatedStorage.Player.Debug:GetDescendants()) do
            if DebugValue:IsA("ValueBase") then
                Iris.SameLine()
                    HelpMarker("Path: "..GetPathOfDebugValue(DebugValue, ReplicatedStorage.Player.Debug))
                    Iris.Text({DebugValue.Name..": "..tostring(DebugValue.Value)})
                Iris.End()
            end
        end
        Iris.End()
    end

    Iris.End()
end

function DeveloperGuiController:PerformanceWindow()
    local Window = Iris.Window({"Performance", false, false, false, true})
    if Window.state.isOpened and Window.state.isUncollapsed then
        Iris.Text({`FPS: {tostring(Stats.FPS)}`})
        Iris.Text({`Ping (ms): {tostring(Stats.Ping)}`})

        Iris.Text({`Window Focused: {tostring(Stats.TabbedIn)}`})
        Iris.Text({`Fullscreen: {tostring(Stats.Fullscreen)}`})
    end
    Iris.End()
end

function DeveloperGuiController:Visuals()
    local MiningRangeSettings = {
        Visible = Iris.State(false);
        AlwaysOnTop = Iris.State(true);
        Color = Iris.State(Color3.new(1, 0, 0));
        Transparency = Iris.State(0);
        TextSize = Iris.State(20);
    }

    local DialogueNPCs = {
        Visible = Iris.State(false);
        AlwaysOnTop = Iris.State(true);
        Color = Iris.State(Color3.new(1, 0, 1));
        Transparency = Iris.State(0);
        TextSize = Iris.State(20);
    }

    local EspSettings = {
        Visible = Iris.State(false);
        AlwaysOnTop = Iris.State(true);
        Lines = Iris.State(true);
        ShowSelf = Iris.State(false);
        Color = Iris.State(Color3.new(1, 1, 0));
        Transparency = Iris.State(0);
        TextSize = Iris.State(20);
    }

    local Window = Iris.Window({"Visuals", false, false, false, true})
    if Window.state.isOpened and Window.state.isUncollapsed then
        Iris.Tree({"MiningRange"})
        Iris.Checkbox({"Visible"}, {isChecked = MiningRangeSettings.Visible})

        Iris.SameLine()
        HelpMarker("Draws debug over world geometry")
        Iris.Checkbox({"Always on top"}, {isChecked = MiningRangeSettings.AlwaysOnTop})
        Iris.End()

        Iris.InputColor4({"Color"}, {color = MiningRangeSettings.Color, transparency = MiningRangeSettings.Transparency})
        Iris.SliderNum({"Text Size", 1, 10, 50}, {number = MiningRangeSettings.TextSize})
        Iris.End()



        Iris.Tree({"Dialogue NPCs"})
        Iris.Checkbox({"Visible"}, {isChecked = DialogueNPCs.Visible})

        Iris.SameLine()
        HelpMarker("Draws debug over world geometry")
        Iris.Checkbox({"Always on top"}, {isChecked = DialogueNPCs.AlwaysOnTop})
        Iris.End()

        Iris.InputColor4({"Color"}, {color = DialogueNPCs.Color, transparency = DialogueNPCs.Transparency})
        Iris.SliderNum({"Text Size", 1, 10, 50}, {number = DialogueNPCs.TextSize})
        Iris.End()



        Iris.Tree({"Player ESP"})
        Iris.Checkbox({"Visible"}, {isChecked = EspSettings.Visible})
        Iris.SameLine()
        HelpMarker("Should you be included in the ESP")
        Iris.Checkbox({"Show self"}, {isChecked = EspSettings.ShowSelf})
        Iris.End()

        Iris.SameLine()
        HelpMarker("Draws lines to players")
        Iris.Checkbox({"Lines"}, {isChecked = EspSettings.Lines})
        Iris.End()

        Iris.SameLine()
        HelpMarker("Draws debug over world geometry")
        Iris.Checkbox({"Always on top"}, {isChecked = EspSettings.AlwaysOnTop})
        Iris.End()

        Iris.InputColor4({"Color"}, {color = EspSettings.Color, transparency = EspSettings.Transparency})
        Iris.SliderNum({"Text Size", 1, 10, 50}, {number = EspSettings.TextSize})
        Iris.End()
    end
    Iris.End()

    if MiningRangeSettings.Visible:get() then
        ImGizmo.SetStyle(MiningRangeSettings.Color:get(), MiningRangeSettings.Transparency:get(), MiningRangeSettings.AlwaysOnTop:get())
        ImGizmo.Sphere:Draw(CFrame.new(Knit.Player.Character.PrimaryPart.CFrame.Position or Vector3.zero), MiningRange, 25, 360)
        ImGizmo.Text:Draw(Knit.Player.Character.PrimaryPart.CFrame.Position or Vector3.zero, "Range: "..tostring(MiningRange), MiningRangeSettings.TextSize:get())
    end

    if DialogueNPCs.Visible:get() then
        local Prompts = CollectionService:GetTagged(DialoguePromptTag)
        ImGizmo.SetStyle(DialogueNPCs.Color:get(), DialogueNPCs.Transparency:get(), DialogueNPCs.AlwaysOnTop:get())

        for _, Prompt :ProximityPrompt in pairs(Prompts) do
            local Position = Prompt.Parent:IsA("Model") and Prompt.Parent.PrimaryPart.CFrame.Position or Prompt.Parent.CFrame.Position
            ImGizmo.Box:Draw(CFrame.new(Position), Vector3.new(2, 5, 2), false)
            ImGizmo.Text:Draw(Position, "Dialogue NPC", DialogueNPCs.TextSize:get())
        end
    end

    if EspSettings.Visible:get() then
        local Characters = workspace.Game.Players:GetChildren()
        ImGizmo.SetStyle(EspSettings.Color:get(), EspSettings.Transparency:get(), EspSettings.AlwaysOnTop:get())

        for _, Character :Model in pairs(Characters) do
            local Player = Players:GetPlayerFromCharacter(Character)
            local Position = Character.PrimaryPart.CFrame.Position

            if (Player and Player.UserId or 0 == Knit.Player.UserId) and not EspSettings.ShowSelf:get() then continue end
            ImGizmo.Box:Draw(CFrame.new(Position - Vector3.new(0, 2.5, 0)), Vector3.new(2, 5, 2), false)
            ImGizmo.Text:Draw(Position, Player and (Player.DisplayName.."(@"..Player.Name..")") or "NPC: "..Character.Name, EspSettings.TextSize:get())

            if EspSettings.Lines:get() then
                local PlayerPosition = Knit.Player.Character and Knit.Player.Character.PrimaryPart.CFrame.Position or Vector3.zero
                local Direction = (Position - PlayerPosition).Unit
                local Length = (Position - PlayerPosition).Magnitude
                local Midpoint = (PlayerPosition + Position) / 2
                ImGizmo.Line:Draw(CFrame.new(Midpoint, Midpoint + Direction), Length)
            end
        end
    end
end

function DeveloperGuiController:Statistics()
    local Window = Iris.Window({"Developer Gui", false, false, false, true})
    if Window.state.isOpened and Window.state.isUncollapsed then
        Iris.SeparatorText({"Mine"})
        Iris.Text({`Blocks generated: {DebugFolder.Mine.BlocksGenerated.Value}`})
        Iris.Text({`Ores generated: {DebugFolder.Mine.OresGenerated.Value}`})
        Iris.Text({`Blocks for collapse: {Core.GameConfig.Mine.BlocksToCollapse}`})
        Iris.Text({`Blocks until collapse: {Core.GameConfig.Mine.BlocksToCollapse - DebugFolder.Mine.BlocksGenerated.Value}`})

        Iris.SeparatorText({"Audio"})
        Iris.Text({`Total sounds made: {DebugFolder.Audio.TotalSoundsMade.Value}`})
        Iris.Text({`Total active sounds: {DebugFolder.Audio.ActiveSounds.Value}`})
        Iris.Text({`Active global sounds: {DebugFolder.Audio.ActiveGlobalSounds.Value}`})
        Iris.Text({`Active positional made: {DebugFolder.Audio.ActivePositionalSounds.Value}`})
    end
    Iris.End()
end

function DeveloperGuiController:Render()
    local AutoGenWindowOpen = Iris.State(false)
    local PerformanceWindowOpen = Iris.State(false)
    local VisualsWindowOpen = Iris.State(false)
    local StatisticsWindowOpen = Iris.State(false)


    -- Main Window
    local Window = Iris.Window({"Developer Gui", false, false, false, true})
    if Window.state.isOpened and Window.state.isUncollapsed then
        Iris.Text({"Here you are, the developer GUI. Here you can open and close many different debug windows. No, nothing here gives you admin, ores or pickaxes. This only DISPLAYS INFORMATION"})
        Iris.Checkbox({"Auto Generated Debug Window"}, {isChecked = AutoGenWindowOpen})
        Iris.Checkbox({"Performance"}, {isChecked = PerformanceWindowOpen})
        Iris.Checkbox({"Visuals"}, {isChecked = VisualsWindowOpen})
        Iris.Checkbox({"Statistics"}, {isChecked = StatisticsWindowOpen})
    end
    Iris.End()

    -- Other windows
    if AutoGenWindowOpen:get() then
        self:AutoGeneratedWindow()
    end

    if PerformanceWindowOpen:get() then
        self:PerformanceWindow()
    end

    if VisualsWindowOpen:get() then
        self:Visuals()
    end

    if StatisticsWindowOpen:get() then
        self:Statistics()
    end
end



-- [[ KNIT ]] --

function DeveloperGuiController:KnitInit()
    ImGizmo:Init()
    Iris.PushConfig({TextWrapped = true})
end

function DeveloperGuiController:KnitStart()
    PickaxeService = Knit.GetService("PickaxeService")
    DialogueService = Knit.GetService("DialogueService")

    UserInputService.InputBegan:Connect(function(Input, Processed)
        if Processed then return end
        if Input.KeyCode ~= Enum.KeyCode.Z then return end

        ReplicatedStorage.Player.Debug.DebugMode.Value = not ReplicatedStorage.Player.Debug.DebugMode.Value
    end)

    UserInputService.WindowFocusReleased:Connect(function()
        Stats.TabbedIn = false
        Iris:ForceRefresh()
    end)

    UserInputService.WindowFocused:Connect(function()
        Stats.TabbedIn = true
    end)

    local GetTime = RunService:IsRunning() and time or os.clock
    local FrameUpdates = {}
    local StartTime = GetTime()
    local LastTime = 0
    local GameSettings = UserSettings().GameSettings

    DialogueService:GetTags():andThen(function(PromptTag :string)
        DialoguePromptTag = PromptTag
    end)

    PickaxeService.UpdateMiningPower:Connect(function()
        PickaxeService:GetPickaxe():andThen(function(Pickaxe :Tool)
            if not Pickaxe then return end

            MiningRange = Pickaxe:GetAttribute("Range")
        end)
    end)

    Iris:Connect(function()
        if ReplicatedStorage.Player.Debug.DebugMode.Value then
            self:Render()

            LastTime = GetTime()

            for Index = #FrameUpdates, 1, -1 do
                FrameUpdates[Index + 1] = FrameUpdates[Index] >= LastTime - 1 and FrameUpdates[Index] or nil
            end

            FrameUpdates[1] = LastTime
            Stats.FPS = math.floor(GetTime() - StartTime >= 1 and #FrameUpdates or #FrameUpdates / (GetTime() - StartTime))
            Stats.Fullscreen = GameSettings:InFullScreen()
            Stats.Ping = Core.Util:RoundToxDP(Knit.Player:GetNetworkPing(), 0)
        end
    end)
end

return DeveloperGuiController