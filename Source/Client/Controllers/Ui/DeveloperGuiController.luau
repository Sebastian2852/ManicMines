local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Iris = require(ReplicatedStorage.Packages.Iris)

local Core = require(ReplicatedStorage.Game.Modules.Core)

local DeveloperGuiController = Knit.CreateController { Name = "DeveloperGuiController" }

local AutoGenWindowOpen = Iris.State(false)
local PerformanceWindowOpen = Iris.State(false)

local Stats = {
    FPS = 0;
    Ping = 0;
    Fullscreen = false;
    TabbedIn = true;
}

-- [[ PRIVATE ]] --

local function HelpMarker(helpText: string)
    Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
    local text = Iris.Text({ "(?)" })
    Iris.PopConfig()

    Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
    if text.hovered() then
        Iris.Tooltip({ helpText })
    end
    Iris.PopConfig()
end

local function GetPathOfDebugValue(Value :Instance, RootFolder :Folder) :string
    local Current = Value
    local Path = {}

    while Current and Current ~= RootFolder do
        table.insert(Path, 1, Current.Name)
        Current = Current.Parent
    end

    if Current == RootFolder then
        return RootFolder.Name.."/"..table.concat(Path, "/")
    end

    return "INVALID: OBJECT NOT DESCENDANT"
end



-- [[ PUBLIC ]] --

function DeveloperGuiController:AutoGeneratedWindow()
    local Window = Iris.Window({"Auto-Generated", false, false, false, true})
    if Window.state.isOpened or Window.state.isUncollapsed then
        Iris.Text({"Everything in this window is auto generated, although information is accurate it may be hard to find or not displayed as intended!"})
        Iris.Tree({"All values"})
        for _, DebugValue :ValueBase in pairs(ReplicatedStorage.Player.Debug:GetDescendants()) do
            if DebugValue:IsA("ValueBase") then
                Iris.SameLine()
                    HelpMarker("Path: "..GetPathOfDebugValue(DebugValue, ReplicatedStorage.Player.Debug))
                    Iris.Text({DebugValue.Name..": "..tostring(DebugValue.Value)})
                Iris.End()
            end
        end
        Iris.End()
    end

    Iris.End()
end

function DeveloperGuiController:PerformanceWindow()
    local Window = Iris.Window({"Performance", false, false, false, true})
    if Window.state.isOpened or Window.state.isUncollapsed then
        Iris.Text({`FPS: {tostring(Stats.FPS)}`})
        Iris.Text({`Ping (ms): {tostring(Stats.Ping)}`})

        Iris.Text({`Window Focused: {tostring(Stats.TabbedIn)}`})
        Iris.Text({`Fullscreen: {tostring(Stats.Fullscreen)}`})
    end
    Iris.End()
end

function DeveloperGuiController:Render()
    -- Main Window
    local Window = Iris.Window({"Developer Gui", false, false, false, true})
    if Window.state.isOpened or Window.state.isUncollapsed then
        Iris.Text({"Here you are, the developer GUI. Here you can open and close many different debug windows. No, nothing here gives you admin, ores or pickaxes. This only DISPLAYS INFORMATION"})
        Iris.Checkbox({"Auto Generated Debug Window"}, {isChecked = AutoGenWindowOpen})
        Iris.Checkbox({"Performance"}, {isChecked = PerformanceWindowOpen})
    end
    Iris.End()

    -- Other windows
    if AutoGenWindowOpen:get() then
        self:AutoGeneratedWindow()
    end

    if PerformanceWindowOpen:get() then
        self:PerformanceWindow()
    end
end



-- [[ KNIT ]] --

function DeveloperGuiController:KnitInit()
    Iris.PushConfig({TextWrapped = true})
end

function DeveloperGuiController:KnitStart()
    UserInputService.InputBegan:Connect(function(Input, Processed)
        if Processed then return end
        if Input.KeyCode ~= Enum.KeyCode.Z then return end

        ReplicatedStorage.Player.Debug.DebugMode.Value = not ReplicatedStorage.Player.Debug.DebugMode.Value
    end)

    UserInputService.WindowFocusReleased:Connect(function()
        Stats.TabbedIn = false
        Iris:ForceRefresh()
    end)

    UserInputService.WindowFocused:Connect(function()
        Stats.TabbedIn = true
    end)

    local GetTime = RunService:IsRunning() and time or os.clock
    local FrameUpdates = {}
    local StartTime = GetTime()
    local LastTime = 0
    local GameSettings = UserSettings().GameSettings

    Iris:Connect(function()
        if ReplicatedStorage.Player.Debug.DebugMode.Value then
            self:Render()

            LastTime = GetTime()

            for Index = #FrameUpdates, 1, -1 do
                FrameUpdates[Index + 1] = FrameUpdates[Index] >= LastTime - 1 and FrameUpdates[Index] or nil
            end

            FrameUpdates[1] = LastTime
            Stats.FPS = math.floor(GetTime() - StartTime >= 1 and #FrameUpdates or #FrameUpdates / (GetTime() - StartTime))
            Stats.Fullscreen = GameSettings:InFullScreen()
            Stats.Ping = Core.Util:RoundToxDP(Knit.Player:GetNetworkPing(), 0)
        end
    end)
end

return DeveloperGuiController